import 'package:hive/hive.dart';
import 'package:keepjoy_app/models/memory.dart';

part 'memory_hive.g.dart';

/// Hive model for Memory
/// TypeAdapter will be generated by build_runner
@HiveType(typeId: 0)
class MemoryHive extends HiveObject {
  @HiveField(0)
  String id;

  @HiveField(1)
  String userId;

  @HiveField(2)
  String title;

  @HiveField(3)
  String? description;

  @HiveField(4)
  String? photoPath; // Deprecated - kept for backward compatibility

  @HiveField(5)
  DateTime createdAt;

  @HiveField(23)
  String? localPhotoPath;

  @HiveField(24)
  String? remotePhotoPath;

  @HiveField(6)
  DateTime? updatedAt;

  @HiveField(7)
  String type; // Store as string (enum name)

  @HiveField(8)
  String? itemName;

  @HiveField(9)
  String? category;

  @HiveField(10)
  String? notes;

  @HiveField(11)
  String? sentiment; // Store as string (enum name)

  @HiveField(12)
  DateTime? syncedAt; // Last sync timestamp

  @HiveField(13)
  bool isDirty; // Local changes not synced

  @HiveField(14)
  bool isDeleted; // Soft delete flag

  MemoryHive({
    required this.id,
    required this.userId,
    required this.title,
    this.description,
    this.photoPath, // Deprecated
    required this.createdAt,
    this.updatedAt,
    required this.type,
    this.itemName,
    this.category,
    this.notes,
    this.sentiment,
    this.syncedAt,
    this.isDirty = false,
    this.isDeleted = false,
    this.localPhotoPath,
    this.remotePhotoPath,
  });

  /// Convert from domain Memory model
  factory MemoryHive.fromMemory(Memory memory, {bool isDirty = false}) {
    return MemoryHive(
      id: memory.id,
      userId: memory.userId,
      title: memory.title,
      description: memory.description,
      photoPath: null, // Deprecated field
      createdAt: memory.createdAt,
      updatedAt: memory.updatedAt,
      type: memory.type.name,
      itemName: memory.itemName,
      category: memory.category,
      notes: memory.notes,
      sentiment: memory.sentiment?.name,
      syncedAt: isDirty ? null : DateTime.now(),
      isDirty: isDirty,
      isDeleted: false,
      localPhotoPath: memory.localPhotoPath,
      remotePhotoPath: memory.remotePhotoPath,
    );
  }

  /// Convert to domain Memory model
  Memory toMemory() {
    // Backward compatibility: migrate old photoPath to new fields
    String? local = localPhotoPath;
    String? remote = remotePhotoPath;

    if (photoPath != null && photoPath!.isNotEmpty) {
      if (photoPath!.startsWith('http')) {
        remote ??= photoPath;
      } else {
        local ??= photoPath;
      }
    }

    return Memory(
      id: id,
      userId: userId,
      title: title,
      description: description,
      localPhotoPath: local,
      remotePhotoPath: remote,
      createdAt: createdAt,
      updatedAt: updatedAt,
      type: MemoryType.values.firstWhere((e) => e.name == type),
      itemName: itemName,
      category: category,
      notes: notes,
      sentiment: sentiment != null
          ? MemorySentiment.values.firstWhere(
              (e) => e.name == sentiment,
              orElse: () => MemorySentiment.happy,
            )
          : null,
    );
  }

  /// Mark as dirty (needs sync)
  void markDirty() {
    isDirty = true;
    updatedAt = DateTime.now();
  }

  /// Mark as synced
  void markSynced() {
    isDirty = false;
    syncedAt = DateTime.now();
  }

  /// Soft delete
  void markDeleted() {
    isDeleted = true;
    isDirty = true;
    updatedAt = DateTime.now();
  }
}
